<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>WebGL Instanced Letters</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        width: 100vw;
        height: 100vh;
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="glcanvas"></canvas>
    <script type="module">
      const canvas = document.getElementById('glcanvas')
      const gl = canvas.getContext('webgl2')

      canvas.width = window.innerWidth
      canvas.height = window.innerHeight

      // ========== SHADERS ==========

      const vsSource = `#version 300 es
in vec2 aQuadPos;
in vec2 aInstancePos;
in float aCharIndex;

uniform vec2 uResolution;
uniform vec2 uAtlasGridSize;

out vec2 vUv;

void main() {
  // Convert to NDC
  vec2 pos = (aInstancePos + aQuadPos * 20.0) / uResolution * 2.0 - 1.0;
  pos.y *= -1.0;

  gl_Position = vec4(pos, 0.0, 1.0);

  // Get character UV from atlas grid (e.g. "A" is index 0, at (0, 0))
  float col = mod(aCharIndex, uAtlasGridSize.x);
  float row = floor(aCharIndex / uAtlasGridSize.x);
  vec2 uvOffset = vec2(col, row) / uAtlasGridSize;

  vUv = (aQuadPos + 0.5) / uAtlasGridSize + uvOffset;
}
`

      const fsSource = `#version 300 es
precision mediump float;

uniform sampler2D uFontAtlas;
in vec2 vUv;
out vec4 outColor;

void main() {
  vec4 col = texture(uFontAtlas, vUv);
  float alpha = col.a;
  if (alpha < 0.01) discard;
  outColor = vec4(0.0, 0.0, 0.0, alpha); // black text
}
`

      // ========== SHADER COMPILATION ==========
      function createShader(gl, type, source) {
        const shader = gl.createShader(type)
        gl.shaderSource(shader, source)
        gl.compileShader(shader)
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(shader))
          gl.deleteShader(shader)
        }
        return shader
      }

      function createProgram(gl, vsSource, fsSource) {
        const vs = createShader(gl, gl.VERTEX_SHADER, vsSource)
        const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource)
        const program = gl.createProgram()
        gl.attachShader(program, vs)
        gl.attachShader(program, fs)
        gl.linkProgram(program)
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error(gl.getProgramInfoLog(program))
          gl.deleteProgram(program)
        }
        return program
      }

      const program = createProgram(gl, vsSource, fsSource)
      gl.useProgram(program)

      // ========== GEOMETRY: Quad ==========
      const quad = new Float32Array([-0.5, -0.5, 0.5, -0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5, 0.5])

      const quadVBO = gl.createBuffer()
      gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO)
      gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW)

      // ========== INSTANCE DATA ==========
      const numInstances = 100
      const instanceData = new Float32Array(numInstances * 3) // x, y, charIndex

      for (let i = 0; i < numInstances; i++) {
        // const x = Math.random() * canvas.width
        // const y = Math.random() * canvas.height
        const x = (i / numInstances) * (canvas.width / 2)
        const y = 20

        const charIndex = 0 // hardcoded to "A"
        instanceData[i * 3 + 0] = x
        instanceData[i * 3 + 1] = y
        instanceData[i * 3 + 2] = 0
      }

      const instanceVBO = gl.createBuffer()
      gl.bindBuffer(gl.ARRAY_BUFFER, instanceVBO)
      gl.bufferData(gl.ARRAY_BUFFER, instanceData, gl.STATIC_DRAW)

      // ========== VERTEX ATTRIBUTES ==========
      const aQuadPos = gl.getAttribLocation(program, 'aQuadPos')
      const aInstancePos = gl.getAttribLocation(program, 'aInstancePos')
      const aCharIndex = gl.getAttribLocation(program, 'aCharIndex')

      // Quad pos
      gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO)
      gl.enableVertexAttribArray(aQuadPos)
      gl.vertexAttribPointer(aQuadPos, 2, gl.FLOAT, false, 0, 0)
      gl.vertexAttribDivisor(aQuadPos, 0) // shared

      // Instance pos + char index
      gl.bindBuffer(gl.ARRAY_BUFFER, instanceVBO)
      // Position
      gl.enableVertexAttribArray(aInstancePos)
      gl.vertexAttribPointer(aInstancePos, 2, gl.FLOAT, false, 12, 0)
      gl.vertexAttribDivisor(aInstancePos, 1)
      // Char index
      gl.enableVertexAttribArray(aCharIndex)
      gl.vertexAttribPointer(aCharIndex, 1, gl.FLOAT, false, 12, 8)
      gl.vertexAttribDivisor(aCharIndex, 1)

      // ========== UNIFORMS ==========
      const uResolution = gl.getUniformLocation(program, 'uResolution')
      const uAtlasGridSize = gl.getUniformLocation(program, 'uAtlasGridSize')
      const uFontAtlas = gl.getUniformLocation(program, 'uFontAtlas')

      gl.uniform2f(uResolution, canvas.width, canvas.height)
      gl.uniform2f(uAtlasGridSize, 2, 2) // 16x16 grid = 256 glyphs

      // ========== LOAD FONT TEXTURE ==========
      const tex = gl.createTexture()
      const image = new Image()
      image.src = 'my_fonts.png' // Replace with your own atlas!
      image.onload = () => {
        gl.bindTexture(gl.TEXTURE_2D, tex)
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image)
        gl.generateMipmap(gl.TEXTURE_2D)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)

        draw()
      }

      // gl.depthMask(false); // disable depth write
      // gl.disable(gl.DEPTH_TEST); // optionally disable depth test

      function draw() {
        gl.viewport(0, 0, canvas.width, canvas.height)
        gl.clearColor(1, 1, 1, 1)
        gl.clear(gl.COLOR_BUFFER_BIT)

        gl.activeTexture(gl.TEXTURE0)
        gl.bindTexture(gl.TEXTURE_2D, tex)
        gl.uniform1i(uFontAtlas, 0)

        gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, numInstances)
      }
    </script>
  </body>
</html>
