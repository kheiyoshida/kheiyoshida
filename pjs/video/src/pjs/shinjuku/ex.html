<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebGL2 Box (gl-matrix)</title>
  <style>
      html, body { height: 100%; margin: 0; background: #0b0d10; color: #e7ecf2; font-family: monospace; }
      #ui { position: fixed; top: 8px; left: 8px; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; font-size: 13px; }
      canvas { display: block; width: 100%; height: 100%; }
  </style>
</head>
<body>
<div id="ui">
  Rotate: W/S X, A/D Y, Q/E Z<br>
  Move: Arrow Keys XY, PgUp/PgDn Z<br>
  Reset offsets: R<br>
  <label><input id="spin" type="checkbox"/> Spin</label>
  <label><input id="wire" type="checkbox"/> Wireframe</label>
</div>
<canvas id="glcanvas"></canvas>

<script type="module">
  import { mat4 } from 'https://cdn.jsdelivr.net/npm/gl-matrix@3.4.3/esm/index.js';

  const vs = `#version 300 es
precision highp float;
in vec3 aPos;
uniform mat4 uModel;
uniform vec3 uOffsets[8];
void main(){
    vec3 localPos = aPos + uOffsets[gl_VertexID];
    gl_Position = uModel * vec4(localPos, 1.0);
}`;

  const fs = `#version 300 es
precision highp float;
out vec4 outColor;
uniform vec3 uColor;
void main(){
  outColor = vec4(uColor, 1.0);
}`;

  function createProgram(gl, vsSrc, fsSrc){
    const sh = (type, src)=>{ const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s); if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s)); return s; };
    const p = gl.createProgram();
    gl.attachShader(p, sh(gl.VERTEX_SHADER, vsSrc));
    gl.attachShader(p, sh(gl.FRAGMENT_SHADER, fsSrc));
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p));
    return p;
  }

  const canvas = document.getElementById('glcanvas');
  const gl = canvas.getContext('webgl2', { antialias: true, depth: true });

  const corners = new Float32Array([
    -0.5, -0.5, -0.5,
    0.5, -0.5, -0.5,
    0.5,  0.5, -0.5,
    -0.5,  0.5, -0.5,
    -0.5, -0.5,  0.5,
    0.5, -0.5,  0.5,
    0.5,  0.5,  0.5,
    -0.5,  0.5,  0.5,
  ]);

  const idx = new Uint16Array([
    0,1,2, 0,2,3,
    4,6,5, 4,7,6,
    0,3,7, 0,7,4,
    1,5,6, 1,6,2,
    0,4,5, 0,5,1,
    3,2,6, 3,6,7,
  ]);

  const prog = createProgram(gl, vs, fs);
  const loc = {
    aPos: gl.getAttribLocation(prog, 'aPos'),
    uModel: gl.getUniformLocation(prog, 'uModel'),
    uOffsets: Array.from({length:8}, (_,i)=> gl.getUniformLocation(prog, `uOffsets[${i}]`)),
    uColor: gl.getUniformLocation(prog, 'uColor'),
  };

  const vbo = gl.createBuffer();
  const ebo = gl.createBuffer();
  const vao = gl.createVertexArray();

  gl.bindVertexArray(vao);
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  gl.bufferData(gl.ARRAY_BUFFER, corners, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(loc.aPos);
  gl.vertexAttribPointer(loc.aPos, 3, gl.FLOAT, false, 0, 0);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, idx, gl.STATIC_DRAW);

  gl.enable(gl.DEPTH_TEST);
  gl.enable(gl.CULL_FACE);
  gl.clearColor(0.04,0.05,0.06,1);

  const offsets = new Array(8).fill(0).map(()=> [0,0,0]);
  const state = { pos:[0,0,0], rot:[0,0,0], scale:0.9, wireframe:false, spin:false };

  function computeModel(){
    const M = mat4.create();
    mat4.translate(M, M, state.pos);
    mat4.rotateX(M, M, state.rot[0]);
    mat4.rotateY(M, M, state.rot[1]);
    mat4.rotateZ(M, M, state.rot[2]);
    mat4.scale(M, M, [state.scale, state.scale, state.scale]);
    return M;
  }

  function resize(){
    const dpr = window.devicePixelRatio || 1;
    canvas.width = innerWidth*dpr; canvas.height = innerHeight*dpr;
    gl.viewport(0,0,canvas.width,canvas.height);
  }
  window.addEventListener('resize', resize);
  resize();

  const key = new Set();
  window.addEventListener('keydown', e=>{ key.add(e.code); if(e.code==="KeyR"){ for(let i=0;i<8;i++) offsets[i]=[0,0,0]; }});
  window.addEventListener('keyup', e=> key.delete(e.code));

  document.getElementById('wire').addEventListener('change',e=> state.wireframe=e.target.checked);
  document.getElementById('spin').addEventListener('change',e=> state.spin=e.target.checked);

  function step(dt){
    const sp = dt/1000*1.5;
    if(key.has('KeyW')) state.rot[0]-=sp;
    if(key.has('KeyS')) state.rot[0]+=sp;
    if(key.has('KeyA')) state.rot[1]-=sp;
    if(key.has('KeyD')) state.rot[1]+=sp;
    if(key.has('KeyQ')) state.rot[2]-=sp;
    if(key.has('KeyE')) state.rot[2]+=sp;
    if(key.has('ArrowLeft'))  state.pos[0]-=sp;
    if(key.has('ArrowRight')) state.pos[0]+=sp;
    if(key.has('ArrowUp'))    state.pos[1]+=sp;
    if(key.has('ArrowDown'))  state.pos[1]-=sp;
    if(key.has('PageUp'))     state.pos[2]+=sp;
    if(key.has('PageDown'))   state.pos[2]-=sp;
    if(state.spin) state.rot[1]+=sp*0.5;
  }

  let prev=performance.now();
  function frame(now){
    const dt=now-prev; prev=now; step(dt);
    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
    gl.useProgram(prog);
    gl.bindVertexArray(vao);
    gl.uniformMatrix4fv(loc.uModel,false,computeModel());
    for(let i=0;i<8;i++) gl.uniform3fv(loc.uOffsets[i], offsets[i]);
    gl.uniform3fv(loc.uColor, state.wireframe?[0.9,0.55,0.2]:[0.85,0.95,1.0]);
    if(state.wireframe){
      for(let t=0;t<idx.length;t+=3){
        gl.drawElements(gl.LINE_LOOP,3,gl.UNSIGNED_SHORT,t*2);
      }
    } else {
      gl.drawElements(gl.TRIANGLES, idx.length, gl.UNSIGNED_SHORT, 0);
    }
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  window.box = {
    setPosition:(x,y,z)=> state.pos=[x,y,z],
    setRotationEuler:(x,y,z)=> state.rot=[x,y,z],
    setScale:s=> state.scale=s,
    setPointOffset:(i,x,y,z)=> offsets[i]=[x,y,z],
    clearOffsets:()=>{for(let i=0;i<8;i++) offsets[i]=[0,0,0]},
  };
</script>
</body>
</html>
